// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'structure_creator_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$StructureCreatorState {
  RegExp? get regex => throw _privateConstructorUsedError;
  String? get groupNameIdentifier => throw _privateConstructorUsedError;
  List<String> get testStringIdentifiers => throw _privateConstructorUsedError;
  String get testString => throw _privateConstructorUsedError;
  List<String> get editableFieldMatch => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)
        withData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)?
        withData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)?
        withData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithData value) withData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithData value)? withData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithData value)? withData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StructureCreatorStateCopyWith<StructureCreatorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StructureCreatorStateCopyWith<$Res> {
  factory $StructureCreatorStateCopyWith(StructureCreatorState value,
          $Res Function(StructureCreatorState) then) =
      _$StructureCreatorStateCopyWithImpl<$Res, StructureCreatorState>;
  @useResult
  $Res call(
      {RegExp? regex,
      String? groupNameIdentifier,
      List<String> testStringIdentifiers,
      String testString,
      List<String> editableFieldMatch});
}

/// @nodoc
class _$StructureCreatorStateCopyWithImpl<$Res,
        $Val extends StructureCreatorState>
    implements $StructureCreatorStateCopyWith<$Res> {
  _$StructureCreatorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? regex = freezed,
    Object? groupNameIdentifier = freezed,
    Object? testStringIdentifiers = null,
    Object? testString = null,
    Object? editableFieldMatch = null,
  }) {
    return _then(_value.copyWith(
      regex: freezed == regex
          ? _value.regex
          : regex // ignore: cast_nullable_to_non_nullable
              as RegExp?,
      groupNameIdentifier: freezed == groupNameIdentifier
          ? _value.groupNameIdentifier
          : groupNameIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      testStringIdentifiers: null == testStringIdentifiers
          ? _value.testStringIdentifiers
          : testStringIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      testString: null == testString
          ? _value.testString
          : testString // ignore: cast_nullable_to_non_nullable
              as String,
      editableFieldMatch: null == editableFieldMatch
          ? _value.editableFieldMatch
          : editableFieldMatch // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WithDataCopyWith<$Res>
    implements $StructureCreatorStateCopyWith<$Res> {
  factory _$$_WithDataCopyWith(
          _$_WithData value, $Res Function(_$_WithData) then) =
      __$$_WithDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RegExp? regex,
      String? groupNameIdentifier,
      List<String> testStringIdentifiers,
      String testString,
      List<String> editableFieldMatch});
}

/// @nodoc
class __$$_WithDataCopyWithImpl<$Res>
    extends _$StructureCreatorStateCopyWithImpl<$Res, _$_WithData>
    implements _$$_WithDataCopyWith<$Res> {
  __$$_WithDataCopyWithImpl(
      _$_WithData _value, $Res Function(_$_WithData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? regex = freezed,
    Object? groupNameIdentifier = freezed,
    Object? testStringIdentifiers = null,
    Object? testString = null,
    Object? editableFieldMatch = null,
  }) {
    return _then(_$_WithData(
      regex: freezed == regex
          ? _value.regex
          : regex // ignore: cast_nullable_to_non_nullable
              as RegExp?,
      groupNameIdentifier: freezed == groupNameIdentifier
          ? _value.groupNameIdentifier
          : groupNameIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      testStringIdentifiers: null == testStringIdentifiers
          ? _value._testStringIdentifiers
          : testStringIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>,
      testString: null == testString
          ? _value.testString
          : testString // ignore: cast_nullable_to_non_nullable
              as String,
      editableFieldMatch: null == editableFieldMatch
          ? _value._editableFieldMatch
          : editableFieldMatch // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$_WithData implements _WithData {
  const _$_WithData(
      {required this.regex,
      required this.groupNameIdentifier,
      required final List<String> testStringIdentifiers,
      required this.testString,
      required final List<String> editableFieldMatch})
      : _testStringIdentifiers = testStringIdentifiers,
        _editableFieldMatch = editableFieldMatch;

  @override
  final RegExp? regex;
  @override
  final String? groupNameIdentifier;
  final List<String> _testStringIdentifiers;
  @override
  List<String> get testStringIdentifiers {
    if (_testStringIdentifiers is EqualUnmodifiableListView)
      return _testStringIdentifiers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_testStringIdentifiers);
  }

  @override
  final String testString;
  final List<String> _editableFieldMatch;
  @override
  List<String> get editableFieldMatch {
    if (_editableFieldMatch is EqualUnmodifiableListView)
      return _editableFieldMatch;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_editableFieldMatch);
  }

  @override
  String toString() {
    return 'StructureCreatorState.withData(regex: $regex, groupNameIdentifier: $groupNameIdentifier, testStringIdentifiers: $testStringIdentifiers, testString: $testString, editableFieldMatch: $editableFieldMatch)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WithData &&
            (identical(other.regex, regex) || other.regex == regex) &&
            (identical(other.groupNameIdentifier, groupNameIdentifier) ||
                other.groupNameIdentifier == groupNameIdentifier) &&
            const DeepCollectionEquality()
                .equals(other._testStringIdentifiers, _testStringIdentifiers) &&
            (identical(other.testString, testString) ||
                other.testString == testString) &&
            const DeepCollectionEquality()
                .equals(other._editableFieldMatch, _editableFieldMatch));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      regex,
      groupNameIdentifier,
      const DeepCollectionEquality().hash(_testStringIdentifiers),
      testString,
      const DeepCollectionEquality().hash(_editableFieldMatch));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WithDataCopyWith<_$_WithData> get copyWith =>
      __$$_WithDataCopyWithImpl<_$_WithData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)
        withData,
  }) {
    return withData(regex, groupNameIdentifier, testStringIdentifiers,
        testString, editableFieldMatch);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)?
        withData,
  }) {
    return withData?.call(regex, groupNameIdentifier, testStringIdentifiers,
        testString, editableFieldMatch);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            RegExp? regex,
            String? groupNameIdentifier,
            List<String> testStringIdentifiers,
            String testString,
            List<String> editableFieldMatch)?
        withData,
    required TResult orElse(),
  }) {
    if (withData != null) {
      return withData(regex, groupNameIdentifier, testStringIdentifiers,
          testString, editableFieldMatch);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_WithData value) withData,
  }) {
    return withData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_WithData value)? withData,
  }) {
    return withData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_WithData value)? withData,
    required TResult orElse(),
  }) {
    if (withData != null) {
      return withData(this);
    }
    return orElse();
  }
}

abstract class _WithData implements StructureCreatorState {
  const factory _WithData(
      {required final RegExp? regex,
      required final String? groupNameIdentifier,
      required final List<String> testStringIdentifiers,
      required final String testString,
      required final List<String> editableFieldMatch}) = _$_WithData;

  @override
  RegExp? get regex;
  @override
  String? get groupNameIdentifier;
  @override
  List<String> get testStringIdentifiers;
  @override
  String get testString;
  @override
  List<String> get editableFieldMatch;
  @override
  @JsonKey(ignore: true)
  _$$_WithDataCopyWith<_$_WithData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StructureCreatorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StructureCreatorEventCopyWith<$Res> {
  factory $StructureCreatorEventCopyWith(StructureCreatorEvent value,
          $Res Function(StructureCreatorEvent) then) =
      _$StructureCreatorEventCopyWithImpl<$Res, StructureCreatorEvent>;
}

/// @nodoc
class _$StructureCreatorEventCopyWithImpl<$Res,
        $Val extends StructureCreatorEvent>
    implements $StructureCreatorEventCopyWith<$Res> {
  _$StructureCreatorEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpdateStructureRegexCopyWith<$Res> {
  factory _$$_UpdateStructureRegexCopyWith(_$_UpdateStructureRegex value,
          $Res Function(_$_UpdateStructureRegex) then) =
      __$$_UpdateStructureRegexCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {RegExp regex,
      String groupNameIdentifier,
      List<String> editableFieldsName});
}

/// @nodoc
class __$$_UpdateStructureRegexCopyWithImpl<$Res>
    extends _$StructureCreatorEventCopyWithImpl<$Res, _$_UpdateStructureRegex>
    implements _$$_UpdateStructureRegexCopyWith<$Res> {
  __$$_UpdateStructureRegexCopyWithImpl(_$_UpdateStructureRegex _value,
      $Res Function(_$_UpdateStructureRegex) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? regex = null,
    Object? groupNameIdentifier = null,
    Object? editableFieldsName = null,
  }) {
    return _then(_$_UpdateStructureRegex(
      regex: null == regex
          ? _value.regex
          : regex // ignore: cast_nullable_to_non_nullable
              as RegExp,
      groupNameIdentifier: null == groupNameIdentifier
          ? _value.groupNameIdentifier
          : groupNameIdentifier // ignore: cast_nullable_to_non_nullable
              as String,
      editableFieldsName: null == editableFieldsName
          ? _value._editableFieldsName
          : editableFieldsName // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$_UpdateStructureRegex implements _UpdateStructureRegex {
  const _$_UpdateStructureRegex(
      {required this.regex,
      required this.groupNameIdentifier,
      required final List<String> editableFieldsName})
      : _editableFieldsName = editableFieldsName;

  @override
  final RegExp regex;
  @override
  final String groupNameIdentifier;
  final List<String> _editableFieldsName;
  @override
  List<String> get editableFieldsName {
    if (_editableFieldsName is EqualUnmodifiableListView)
      return _editableFieldsName;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_editableFieldsName);
  }

  @override
  String toString() {
    return 'StructureCreatorEvent.updateStructureRegex(regex: $regex, groupNameIdentifier: $groupNameIdentifier, editableFieldsName: $editableFieldsName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateStructureRegex &&
            (identical(other.regex, regex) || other.regex == regex) &&
            (identical(other.groupNameIdentifier, groupNameIdentifier) ||
                other.groupNameIdentifier == groupNameIdentifier) &&
            const DeepCollectionEquality()
                .equals(other._editableFieldsName, _editableFieldsName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, regex, groupNameIdentifier,
      const DeepCollectionEquality().hash(_editableFieldsName));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateStructureRegexCopyWith<_$_UpdateStructureRegex> get copyWith =>
      __$$_UpdateStructureRegexCopyWithImpl<_$_UpdateStructureRegex>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) {
    return updateStructureRegex(regex, groupNameIdentifier, editableFieldsName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) {
    return updateStructureRegex?.call(
        regex, groupNameIdentifier, editableFieldsName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (updateStructureRegex != null) {
      return updateStructureRegex(
          regex, groupNameIdentifier, editableFieldsName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) {
    return updateStructureRegex(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) {
    return updateStructureRegex?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (updateStructureRegex != null) {
      return updateStructureRegex(this);
    }
    return orElse();
  }
}

abstract class _UpdateStructureRegex implements StructureCreatorEvent {
  const factory _UpdateStructureRegex(
          {required final RegExp regex,
          required final String groupNameIdentifier,
          required final List<String> editableFieldsName}) =
      _$_UpdateStructureRegex;

  RegExp get regex;
  String get groupNameIdentifier;
  List<String> get editableFieldsName;
  @JsonKey(ignore: true)
  _$$_UpdateStructureRegexCopyWith<_$_UpdateStructureRegex> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_UpdateTestStringCopyWith<$Res> {
  factory _$$_UpdateTestStringCopyWith(
          _$_UpdateTestString value, $Res Function(_$_UpdateTestString) then) =
      __$$_UpdateTestStringCopyWithImpl<$Res>;
  @useResult
  $Res call({String testString});
}

/// @nodoc
class __$$_UpdateTestStringCopyWithImpl<$Res>
    extends _$StructureCreatorEventCopyWithImpl<$Res, _$_UpdateTestString>
    implements _$$_UpdateTestStringCopyWith<$Res> {
  __$$_UpdateTestStringCopyWithImpl(
      _$_UpdateTestString _value, $Res Function(_$_UpdateTestString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? testString = null,
  }) {
    return _then(_$_UpdateTestString(
      testString: null == testString
          ? _value.testString
          : testString // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_UpdateTestString implements _UpdateTestString {
  const _$_UpdateTestString({required this.testString});

  @override
  final String testString;

  @override
  String toString() {
    return 'StructureCreatorEvent.updateTestString(testString: $testString)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateTestString &&
            (identical(other.testString, testString) ||
                other.testString == testString));
  }

  @override
  int get hashCode => Object.hash(runtimeType, testString);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateTestStringCopyWith<_$_UpdateTestString> get copyWith =>
      __$$_UpdateTestStringCopyWithImpl<_$_UpdateTestString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) {
    return updateTestString(testString);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) {
    return updateTestString?.call(testString);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (updateTestString != null) {
      return updateTestString(testString);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) {
    return updateTestString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) {
    return updateTestString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (updateTestString != null) {
      return updateTestString(this);
    }
    return orElse();
  }
}

abstract class _UpdateTestString implements StructureCreatorEvent {
  const factory _UpdateTestString({required final String testString}) =
      _$_UpdateTestString;

  String get testString;
  @JsonKey(ignore: true)
  _$$_UpdateTestStringCopyWith<_$_UpdateTestString> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ClearFindedGroupsCopyWith<$Res> {
  factory _$$_ClearFindedGroupsCopyWith(_$_ClearFindedGroups value,
          $Res Function(_$_ClearFindedGroups) then) =
      __$$_ClearFindedGroupsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ClearFindedGroupsCopyWithImpl<$Res>
    extends _$StructureCreatorEventCopyWithImpl<$Res, _$_ClearFindedGroups>
    implements _$$_ClearFindedGroupsCopyWith<$Res> {
  __$$_ClearFindedGroupsCopyWithImpl(
      _$_ClearFindedGroups _value, $Res Function(_$_ClearFindedGroups) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ClearFindedGroups implements _ClearFindedGroups {
  const _$_ClearFindedGroups();

  @override
  String toString() {
    return 'StructureCreatorEvent.clearFindedGroups()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ClearFindedGroups);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) {
    return clearFindedGroups();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) {
    return clearFindedGroups?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (clearFindedGroups != null) {
      return clearFindedGroups();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) {
    return clearFindedGroups(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) {
    return clearFindedGroups?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (clearFindedGroups != null) {
      return clearFindedGroups(this);
    }
    return orElse();
  }
}

abstract class _ClearFindedGroups implements StructureCreatorEvent {
  const factory _ClearFindedGroups() = _$_ClearFindedGroups;
}

/// @nodoc
abstract class _$$_CleanRegexIdentifierTextCopyWith<$Res> {
  factory _$$_CleanRegexIdentifierTextCopyWith(
          _$_CleanRegexIdentifierText value,
          $Res Function(_$_CleanRegexIdentifierText) then) =
      __$$_CleanRegexIdentifierTextCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CleanRegexIdentifierTextCopyWithImpl<$Res>
    extends _$StructureCreatorEventCopyWithImpl<$Res,
        _$_CleanRegexIdentifierText>
    implements _$$_CleanRegexIdentifierTextCopyWith<$Res> {
  __$$_CleanRegexIdentifierTextCopyWithImpl(_$_CleanRegexIdentifierText _value,
      $Res Function(_$_CleanRegexIdentifierText) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_CleanRegexIdentifierText implements _CleanRegexIdentifierText {
  const _$_CleanRegexIdentifierText();

  @override
  String toString() {
    return 'StructureCreatorEvent.cleanRegexIdentifierText()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CleanRegexIdentifierText);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) {
    return cleanRegexIdentifierText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) {
    return cleanRegexIdentifierText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (cleanRegexIdentifierText != null) {
      return cleanRegexIdentifierText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) {
    return cleanRegexIdentifierText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) {
    return cleanRegexIdentifierText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (cleanRegexIdentifierText != null) {
      return cleanRegexIdentifierText(this);
    }
    return orElse();
  }
}

abstract class _CleanRegexIdentifierText implements StructureCreatorEvent {
  const factory _CleanRegexIdentifierText() = _$_CleanRegexIdentifierText;
}

/// @nodoc
abstract class _$$_CleanTestStringTextCopyWith<$Res> {
  factory _$$_CleanTestStringTextCopyWith(_$_CleanTestStringText value,
          $Res Function(_$_CleanTestStringText) then) =
      __$$_CleanTestStringTextCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CleanTestStringTextCopyWithImpl<$Res>
    extends _$StructureCreatorEventCopyWithImpl<$Res, _$_CleanTestStringText>
    implements _$$_CleanTestStringTextCopyWith<$Res> {
  __$$_CleanTestStringTextCopyWithImpl(_$_CleanTestStringText _value,
      $Res Function(_$_CleanTestStringText) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_CleanTestStringText implements _CleanTestStringText {
  const _$_CleanTestStringText();

  @override
  String toString() {
    return 'StructureCreatorEvent.cleanTestStringText()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CleanTestStringText);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)
        updateStructureRegex,
    required TResult Function(String testString) updateTestString,
    required TResult Function() clearFindedGroups,
    required TResult Function() cleanRegexIdentifierText,
    required TResult Function() cleanTestStringText,
  }) {
    return cleanTestStringText();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult? Function(String testString)? updateTestString,
    TResult? Function()? clearFindedGroups,
    TResult? Function()? cleanRegexIdentifierText,
    TResult? Function()? cleanTestStringText,
  }) {
    return cleanTestStringText?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegExp regex, String groupNameIdentifier,
            List<String> editableFieldsName)?
        updateStructureRegex,
    TResult Function(String testString)? updateTestString,
    TResult Function()? clearFindedGroups,
    TResult Function()? cleanRegexIdentifierText,
    TResult Function()? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (cleanTestStringText != null) {
      return cleanTestStringText();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateStructureRegex value) updateStructureRegex,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_ClearFindedGroups value) clearFindedGroups,
    required TResult Function(_CleanRegexIdentifierText value)
        cleanRegexIdentifierText,
    required TResult Function(_CleanTestStringText value) cleanTestStringText,
  }) {
    return cleanTestStringText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult? Function(_CleanRegexIdentifierText value)?
        cleanRegexIdentifierText,
    TResult? Function(_CleanTestStringText value)? cleanTestStringText,
  }) {
    return cleanTestStringText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateStructureRegex value)? updateStructureRegex,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_ClearFindedGroups value)? clearFindedGroups,
    TResult Function(_CleanRegexIdentifierText value)? cleanRegexIdentifierText,
    TResult Function(_CleanTestStringText value)? cleanTestStringText,
    required TResult orElse(),
  }) {
    if (cleanTestStringText != null) {
      return cleanTestStringText(this);
    }
    return orElse();
  }
}

abstract class _CleanTestStringText implements StructureCreatorEvent {
  const factory _CleanTestStringText() = _$_CleanTestStringText;
}
